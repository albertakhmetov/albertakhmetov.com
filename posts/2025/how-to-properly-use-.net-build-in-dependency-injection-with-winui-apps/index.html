<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>How to properly use .NET build-in dependency injection with WinUI apps | Albert Akhmetov</title>
<meta name="keywords" content="dependency injection with WinUI, how to use dependency injection with WinUI">
<meta name="description" content="This post is based on Using .NET build-in dependency injection with WinUI apps and represents work on the mistakes made in the design of the approach described there.">
<meta name="author" content="">
<link rel="canonical" href="https://albertakhmetov.com/posts/2025/how-to-properly-use-.net-build-in-dependency-injection-with-winui-apps/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.css" rel="preload stylesheet" as="style">
<link rel="icon" href="https://albertakhmetov.com/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://albertakhmetov.com/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://albertakhmetov.com/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://albertakhmetov.com/apple-touch-icon.png">
<link rel="mask-icon" href="https://albertakhmetov.com/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://albertakhmetov.com/posts/2025/how-to-properly-use-.net-build-in-dependency-injection-with-winui-apps/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="How to properly use .NET build-in dependency injection with WinUI apps" />
<meta property="og:description" content="This post is based on Using .NET build-in dependency injection with WinUI apps and represents work on the mistakes made in the design of the approach described there." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://albertakhmetov.com/posts/2025/how-to-properly-use-.net-build-in-dependency-injection-with-winui-apps/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2025-02-09T12:00:00+05:00" />
<meta property="article:modified_time" content="2025-02-09T12:00:00+05:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="How to properly use .NET build-in dependency injection with WinUI apps"/>
<meta name="twitter:description" content="This post is based on Using .NET build-in dependency injection with WinUI apps and represents work on the mistakes made in the design of the approach described there."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://albertakhmetov.com/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "How to properly use .NET build-in dependency injection with WinUI apps",
      "item": "https://albertakhmetov.com/posts/2025/how-to-properly-use-.net-build-in-dependency-injection-with-winui-apps/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "How to properly use .NET build-in dependency injection with WinUI apps",
  "name": "How to properly use .NET build-in dependency injection with WinUI apps",
  "description": "This post is based on Using .NET build-in dependency injection with WinUI apps and represents work on the mistakes made in the design of the approach described there.\n",
  "keywords": [
    "dependency injection with WinUI", "how to use dependency injection with WinUI"
  ],
  "articleBody": "This post is based on Using .NET build-in dependency injection with WinUI apps and represents work on the mistakes made in the design of the approach described there.\nToo complicated. I realized this after using this approach in several applications. This approach also leads to some interesting (and hard-to-find) bugs. So let’s start from scratch.\nYou still need to control the initialization and shutdown of the application, so you need to add the following lines to the project file:\nDISABLE_XAML_GENERATED_MAIN DependencyInjection.App This control is necessary for us to properly shut down the services in the host. When the application starts, a host object is created. In this host, all the services required for the application to work are registered. After the application ends (even in case of an error), the services are properly shut down after calling the Dispose method of the IHost interface.\n// Note that the Main method has the [STAThread] attribute. [STAThread] public static void Main(string[] args) { WinRT.ComWrappersSupport.InitializeComWrappers(); try { Start(_ =\u003e { var context = new DispatcherQueueSynchronizationContext(DispatcherQueue.GetForCurrentThread()); SynchronizationContext.SetSynchronizationContext(context); var app = new App(); app.UnhandledException += (_, _) =\u003e StopHost(); host = CreateHost(app); }); } finally { StopHost(); } } private static IHost CreateHost(IApp app) { var builder = Host.CreateApplicationBuilder(); builder.Services.AddSingleton(app); builder.Services.AddSingleton(); return builder.Build(); } private static void StopHost() { host?.Dispose(); } private static IHost? host; In our example, the application class itself and the main window are registered as services. The IApp interface consists of just one method - Exit:\npublic interface IApp { void Exit(); } Now we can add a parameterized constructor to MainWindow to receive an instance of the App class. Since MainWindow is also registered as a service, the instance of the App class will be automatically provided.\nprivate readonly IApp app; public MainWindow(IApp app) { this.app = app; this.InitializeComponent(); } After starting the application, the OnLaunched method will be called as usual. There, you can initialize the MainWindow class and open the application window as usual:\nprotected override void OnLaunched(LaunchActivatedEventArgs args) { // The host should already be created by this time. if (host == null) { throw new InvalidOperationException(); } base.OnLaunched(args); mainWindow = host.Services.GetRequiredService(); mainWindow.Closed += OnMainWindowClosed; mainWindow.AppWindow.Show(true); } That’s all you need for a basic implementation of DI (Dependency Injection) in a WinUI application. Much simpler than last time.\nNow let’s look at some implementation details.\nIt’s important to understand that the current implementation does not support IHostedService (since the host is not started). To fix this, you need to:\nAdd the startup code Add the shutdown code You can start the host in the OnLaunched method. Although the method is called RunAsync, it will run as long as the host is active. For this reason, I simply ignore it (hopefully, this isn’t a bad practice):\nmainWindow.AppWindow.Show(true); _ = host.RunAsync(); } It’s best to stop the host right before destroying it. In this case, we need to wait for StopAsync to complete before destroying the host object:\nprivate static void StopHost() { host?.StopAsync().Wait(); host?.Dispose(); } One downside of this approach is that we don’t know exactly when all services will be started. For background tasks, this doesn’t seem very critical (as far as I can tell). In other cases, this needs closer attention.\nAnd finally, I’ll mention a small nuance about unpackaged apps.\nIn theory, if a user wants to open a file using the application (via the “Open With” menu), the path will be passed through the LaunchActivatedEventArgs parameter of the OnLaunched method. However, this doesn’t work for unpackaged apps.\nAnd here, the static Main method comes to the rescue! All we need to do is pass the args array to the App class so it can process it correctly. For example, we pass this array through the constructor and handle it in the OnLaunched method.\nThe source code available here.\n",
  "wordCount" : "665",
  "inLanguage": "en",
  "datePublished": "2025-02-09T12:00:00+05:00",
  "dateModified": "2025-02-09T12:00:00+05:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://albertakhmetov.com/posts/2025/how-to-properly-use-.net-build-in-dependency-injection-with-winui-apps/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Albert Akhmetov",
    "logo": {
      "@type": "ImageObject",
      "url": "https://albertakhmetov.com/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://albertakhmetov.com/" accesskey="h" title="Albert Akhmetov (Alt + H)">Albert Akhmetov</a>
            <div class="logo-switches">
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://albertakhmetov.com/posts/introduce" title="about me">
                    <span>about me</span>
                </a>
            </li>
            <li>
                <a href="https://albertakhmetov.com/tags" title="tags">
                    <span>tags</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      How to properly use .NET build-in dependency injection with WinUI apps
    </h1>
    <div class="post-meta"><span title='2025-02-09 12:00:00 +0500 +05'>February 9, 2025</span>

</div>
  </header> 
  <div class="post-content"><p>This post is based on <a href="https://albertakhmetov.com/posts/2024/using-.net-build-in-dependency-injection-with-winui-apps/">Using .NET build-in dependency injection with WinUI apps</a> and represents work on the mistakes made in the design of the approach described there.</p>
<p>Too complicated. I realized this after using this approach in several applications. This approach also leads to some interesting (and hard-to-find) bugs. So let&rsquo;s start from scratch.</p>
<p>You still need to control the initialization and shutdown of the application, so you need to add the following lines to the project file:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-XML" data-lang="XML"><span style="display:flex;"><span><span style="color:#f92672">&lt;PropertyGroup&gt;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">&lt;!-- Use our own Main entry point so we can control the initialization and shutdown of the application --&gt;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">&lt;DefineConstants&gt;</span>DISABLE_XAML_GENERATED_MAIN<span style="color:#f92672">&lt;/DefineConstants&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">&lt;!-- We use App class to place Main method --&gt;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">&lt;StartupObject&gt;</span>DependencyInjection.App<span style="color:#f92672">&lt;/StartupObject&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">&lt;/PropertyGroup&gt;</span>
</span></span></code></pre></div><p>This control is necessary for us to properly shut down the services in the host. When the application starts, a host object is created. In this host, all the services required for the application to work are registered. After the application ends (even in case of an error), the services are properly shut down after calling the <code>Dispose</code> method of the <code>IHost</code> interface.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C#" data-lang="C#"><span style="display:flex;"><span><span style="color:#75715e">// Note that the Main method has the [STAThread] attribute.</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">[STAThread]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> Main(<span style="color:#66d9ef">string</span>[] args)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    WinRT.ComWrappersSupport.InitializeComWrappers();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">try</span>
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        Start(_ =&gt;
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">var</span> context = <span style="color:#66d9ef">new</span> DispatcherQueueSynchronizationContext(DispatcherQueue.GetForCurrentThread());
</span></span><span style="display:flex;"><span>            SynchronizationContext.SetSynchronizationContext(context);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">var</span> app = <span style="color:#66d9ef">new</span> App();
</span></span><span style="display:flex;"><span>            app.UnhandledException += (_, _) =&gt; StopHost();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            host = CreateHost(app);
</span></span><span style="display:flex;"><span>        });
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">finally</span>
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        StopHost();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> IHost CreateHost(IApp app)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> builder = Host.CreateApplicationBuilder();
</span></span><span style="display:flex;"><span>    builder.Services.AddSingleton&lt;IApp&gt;(app);
</span></span><span style="display:flex;"><span>    builder.Services.AddSingleton&lt;MainWindow&gt;();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> builder.Build();
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> StopHost()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    host?.Dispose();
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> IHost? host;
</span></span></code></pre></div><p>In our example, the application class itself and the main window are registered as services. The <code>IApp</code> interface consists of just one method - <code>Exit</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C#" data-lang="C#"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">IApp</span> 
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> Exit();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Now we can add a parameterized constructor to <code>MainWindow</code> to receive an instance of the <code>App</code> class. Since <code>MainWindow</code> is also registered as a service, the instance of the App class will be automatically provided.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C#" data-lang="C#"><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">readonly</span> IApp app;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> MainWindow(IApp app)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">this</span>.app = app;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">this</span>.InitializeComponent();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>After starting the application, the <code>OnLaunched</code> method will be called as usual. There, you can initialize the MainWindow class and open the application window as usual:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C#" data-lang="C#"><span style="display:flex;"><span><span style="color:#66d9ef">protected</span> <span style="color:#66d9ef">override</span> <span style="color:#66d9ef">void</span> OnLaunched(LaunchActivatedEventArgs args)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// The host should already be created by this time. </span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (host == <span style="color:#66d9ef">null</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> InvalidOperationException();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">base</span>.OnLaunched(args);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    mainWindow = host.Services.GetRequiredService&lt;MainWindow&gt;();
</span></span><span style="display:flex;"><span>    mainWindow.Closed += OnMainWindowClosed;
</span></span><span style="display:flex;"><span>    mainWindow.AppWindow.Show(<span style="color:#66d9ef">true</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>That&rsquo;s all you need for a basic implementation of DI (Dependency Injection) in a WinUI application. Much simpler than last time.</p>
<p>Now let&rsquo;s look at some implementation details.</p>
<p>It&rsquo;s important to understand that the current implementation does not support <code>IHostedService</code> (since the host is not started). To fix this, you need to:</p>
<ul>
<li>Add the startup code</li>
<li>Add the shutdown code</li>
</ul>
<p>You can start the host in the <code>OnLaunched</code> method. Although the method is called <code>RunAsync</code>, it will run as long as the host is active. For this reason, I simply ignore it (hopefully, this isn&rsquo;t a bad practice):</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C#" data-lang="C#"><span style="display:flex;"><span>mainWindow.AppWindow.Show(<span style="color:#66d9ef">true</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>_ = host.RunAsync();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>It&rsquo;s best to stop the host right before destroying it. In this case, we need to wait for StopAsync to complete before destroying the host object:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C#" data-lang="C#"><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> StopHost()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    host?.StopAsync().Wait();
</span></span><span style="display:flex;"><span>    host?.Dispose();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>One downside of this approach is that we don&rsquo;t know exactly when all services will be started. For background tasks, this doesn&rsquo;t seem very critical (as far as I can tell). In other cases, this needs closer attention.</p>
<p>And finally, I&rsquo;ll mention a small nuance about unpackaged apps.</p>
<p>In theory, if a user wants to open a file using the application (via the &ldquo;Open With&rdquo; menu), the path will be passed through the <code>LaunchActivatedEventArgs</code> parameter of the <code>OnLaunched</code> method. However, this doesn&rsquo;t work for unpackaged apps.</p>
<p>And here, the static <code>Main</code> method comes to the rescue! All we need to do is pass the args array to the App class so it can process it correctly. For example, we pass this array through the constructor and handle it in the OnLaunched method.</p>
<p>The source code available <a href="https://github.com/albertakhmetov/albertakhmetov.com/tree/main/DependencyInjection">here</a>.</p>

  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://albertakhmetov.com/tags/c%23/">C#</a></li>
      <li><a href="https://albertakhmetov.com/tags/.net/">.NET</a></li>
      <li><a href="https://albertakhmetov.com/tags/winui/">WinUI</a></li>
      <li><a href="https://albertakhmetov.com/tags/di/">DI</a></li>
      <li><a href="https://albertakhmetov.com/tags/ioc/">IoC</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://albertakhmetov.com/">Albert Akhmetov</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
